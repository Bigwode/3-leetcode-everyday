## c++程序设计语言读书笔记

### 第二章 C++简单程序设计

**auto**存储类型采用的是堆栈方式分配内存，属于暂时性存储。

**static**存储类型，在内存中是以固定地址存放的，在程序运行期间都有效。

**符号常量**的定义：给常量命名，**const + 数据类型+ 常量名=常量值;**

c++中唯一的三元运算符---**条件运算符**

**表达式1？表达式2：表达式3；**

### 第三章 函数

注意，值传递与引用传递

**内联函数：** 对于一些功能简单，规模较小而使用又频繁的函数，可以使用关键字inline，好处是节省了参数传递、控制转移等开销。但是，编译器并不保证这将成为内联函数。

有默认值的形参必须放在最后。在函数声明的时候将默认值表示出来，但是在函数定义的时候就不能在说明默认值了。

**函数重载**

重载函数的形参必须不同：**个数不同或者类型不同。**注意不能使用返回值不同的两个函数来作为函数的重载。

函数形参和局部变量不能像全局变量一样使用固定地址存储，它是存储在**栈**中。

### 第四章 类与对象

public作为外部接口，private不能被类外部访问，protected可以被派生类访问，但是仍然不能被外部访问。

对象所占用的内存空间只用于存放数据成员，函数成员不在每个对象中存储副本，每个函数的代码在内存中只占据一份空间。

函数的原型声明放在类体内，用来说明参数表和返回值类型。具体实现可以写在类定义之外。

返回值类型 类名：：函数成员（）{}

**构造函数**的函数名与类名相同且没有返回值。

优雅的使用构造函数的**initialization List**.

Class(double m = 0, double n = 1) : x(m), y(n) {}为数据变量x,y赋初始值。

**复制构造函数：**（拷贝构造函数）其形参是**本类的对象的引用**，作用是使用一个已经存在的对象，去初始化同类的一个新对象。

语法形式如，**类名（类名& 对象名）；** **注意：拷贝构造函数可以访问私有数据成员。**

**复制构造函数在三种情况下会被调用。**

1.使用类的一个对象去初始化该类的另外一个对象。

2.如果函数的形参是类的对象，调用函数时，进行形参和实参结合时。（相当于传值引用会调用复制构造函数，所以传递比较大的对象时，传递引用效率更高）

3.如果函数的返回值是类对象，返回函数时，调用复制构造函数。--用于创建无名临时对象。127页

**析构函数**

~Class(){};  //不接受任何参数，但可以是虚函数。

**组合类对象调用构造函数的顺序**：先调用内嵌对象的构造函数，调用顺序按照内嵌对象在组合类的定义中出现的次序，再调用本类的构造函数。析构函数相反。

**前向引用声明**

当两个类存在相互调用的情况，例如A类的成员函数的形参是B的对象，因为两个类的定义有次序，所以放谁在前都会出现未定义错误。在类A定义前使用Class B;作为前向引用声明。

但是在提供完整的类定义之前，仍然不能定义该类的对象或使用该类的对象。

但是可以定义该类的对象引用或者指针。

**结构体和联合体union.**

由于联合体的全部数据成员共享同一组内存单元，所以联合体变量中的成员同时之多只有一个是有意义的。

### 第五章 数据的共享与保护

标识符的**可见性**讨论的是是否可以被引用。

如果对象的生存期和程序运行期相同，则称他具有**静态生存期**。

如果要在函数内部的局部作用域中声明具有静态生存期的对象，要使用**关键字static**。函数内部定义的静态局部变量不会在每次进入函数的时候创建副本，只会被初始化一次。

**全局变量和静态变量的区别：**

全局变量和静态局部变量和静态全局变量都是在静态存储区（全局数据区）中分配空间的，而局部变量是在**栈**上分配空间的。

全局变量作用域是整个项目，其他不包括全局变量定义的文件只需要使用extern关键字声明就可以继续使用，而静态全局变量是当前文件，静态局部变量是当前函数体内部。

**静态数据成员：**

静态成员在每个类中只有一个副本，由该类的所有对象共同维护使用。

类的静态数据成员需要在类定义之外再加以定义，是因为它需要专门为他们分配空间。而非静态数据成员的空间是与他们所属对象的空间同时分配的。

注意，虽然静态数据成员是私有的，但是也可以在类外直接初始化。

**静态函数成员：**

静态成员函数一般习惯于通过类名（或者对象名）来调用，而非静态成员函数只能通过对象名来调用。

静态成员函数可以直接访问该类的静态数据成员和函数成员，而访问非静态成员，必须通过对象名。

**友元函数 friend**

一个普通函数或者类的成员函数可以访问封装于另外一个类中的数据。

**在友元函数中可以通过对象名直接来访问类的私有数据成员。**

友元关系不能传递；有友元关系是单向的；友元关系不能被继承。

**常对象** 

**const 类型说明符 对象名；**

必须进行初始化，而且不能被更新。

用const关键字修饰的类成员函数为**常成员函数**：**类型说明符 函数名（参数表）const；**

常对象只能调用它的常成员函数，而不能调用其他成员函数。

const关键字可以用于重载函数的区分。

静态常数据成员在类外说明和初始化。

常数据成员只能通过初始化列表来获得初值。

类成员中的静态变量和常量都应当在类定义之外进行定义。例外是，类的静态常量如果是整型或者枚举型，则可以直接在类定义中为它指定常量值。

**常引用**所引用的对象不能被更新。

c++语法要求一个类的定义必须出现在所有使用该类的编译单元中，习惯上，将类的定义写在头文件中。

### 第六章 数组、指针和字符串

使用数组名传递数据时，传递的是地址。

对象数组的元素是对象。

指针变量用于存放内存单元地址。

数组名就是一个指针常量。

**指向常量的指针**const int * p = &a；和**指针类型的常量**int * const p = &a；

**指针数组** 数据类型 * 数组名[下标表达式]；数组的元素都是指针变量。

**对象指针** 类名 * 对象指针名；

适用对象指针访问对象的成员：**对象指针名->成员名**；

**this指针**是一个隐含于每一个类的**非静态成员函数**中的特殊指针（包括构造函数和析构函数），用于指向正在被成员函数操作的对象。

**new**返回一个指向新分配内存首地址的类型的指针。

**new动态创建一位数组：new 类型名[数组长度]；** **delete[] 指针名；**

**动态数组 vector<元素类型>数组对象名(数组长度)；**

**c++深复制和浅复制区别**

如果一个类没有提供拷贝构造函数，当用该类的一个对象去给另外一个对象赋值的时候就是浅拷贝。导致两个指针指向同一块内存，析构的时候出现指针悬挂问题出错。深拷贝会在堆内存中另外申请空间来存储数据，从而解决了指针悬挂的问题，当数据成员中有指针的时候，必须使用深拷贝。

**字符串**

### 第七章 继承与派生

Class Derivated: public(继承方式) Base1, private Base2{}













