## c++程序设计语言读书笔记

### 第二章 C++简单程序设计

**auto**存储类型采用的是**堆栈**方式分配内存，属于暂时性存储。

**static**存储类型，在内存中是以固定地址存放的，在程序运行期间都有效。

**符号常量**的定义：给常量命名，**const + 数据类型+ 常量名=常量值;** 符号常量在声明时一定要赋初值，而在程序中间不能改变其值。

c++中唯一的三元运算符---**条件运算符**

**表达式1？表达式2：表达式3；**

```c++
switch (表达式)
{
case1: 常量表达式1：语句1；break;
...
}
```

typedef声明：将一个已有的标识符声明为某个数据类型的别名。

typedef 已有类型名 新类型名；

枚举类型enum 枚举类型名 {变量值列表}；

### 第三章 函数

函数的参数传递：

**值传递**：是指当发生函数调用的时候，给形参分配内存空间，并用实参来初始化形参（直接将实参的值传递给形参）是一个单向传递过程，形参值的改变对实参不起作用。

**引用传递**： 将引用作为形参，在函数调用时发生的参数传递成为引用传递。对形参的任何操作也就会直接作用于实参。**引用**是一种特殊类型的变量，可以认为是另一个变量的别名。

声明引用必须初始化且不能改变。

**内联函数：** 对于一些功能简单，规模较小而使用又频繁的函数，可以使用**关键字inline**，好处是节省了参数传递、控制转移等开销。但是，编译器并不保证这将成为内联函数。

有默认值的形参必须放在最后。在函数声明的时候将默认值表示出来，但是在函数定义的时候就不能在说明默认值了。

在相同的作用域内，不允许在同一个函数的多个声明中对同一个参数的默认值重复定义，及时前后定义的值相同也不行。

**函数重载**

重载函数的形参必须不同：**个数不同或者类型不同。**注意不能使用返回值不同的两个函数来作为函数的重载。

函数形参和局部变量不能像全局变量一样使用固定地址存储，它是存储在**栈**中（运行栈）。

### 第四章 类与对象

将**抽象**后的数据和函数**封装**在一起，便构成C++的类。

类的实例化：定义类的变量，即类的对象（或实例）。

public作为外部接口，private不能被类外部访问，protected可以被派生类访问，但是仍然不能被外部访问。

声明一个对象： 类名 对象名；

对象所占用的内存空间只用于存放数据成员，函数成员不在每个对象中存储副本，每个函数的代码在内存中只占据一份空间。

访问数据成员：对象名.数据成员名

调用函数成员：对象名.成员函数名(参数列表)

成员函数的原型声明要放在类体内，用来说明参数表和返回值类型。具体实现可以写在类定义之外。

```c++
返回值类型 类名：：成员函数名（参数表）{函数体}
```

**内敛函数**的声明：

隐式声明：将函数体直接放在类体内、显式声明：inline关键字。

**4.3、构造函数和析构函数**

**构造函数**的函数名与类名相同且没有返回值，构造函数在对象被创建的时候将自动被调用。

构造函数可以重载，可以是内联函数，可以带有参数表，可以带有默认的形参值。

```c++
 // 优雅的使用构造函数的initialization List.
Class_name(double m = 0, double n = 1) : x(m), y(n) {}为数据变量x,y赋初始值。
```

复制构造函数：（**拷贝构造函数**）其形参是**本类的对象的引用**，作用是使用一个已经存在的对象，去初始化同类的一个新对象。

语法形式如，

```c++
类名（类名& 对象名）；
```

**注意：拷贝构造函数可以访问私有数据成员。**

**拷贝构造函数在三种情况下会被调用。**

1.使用类的一个对象去初始化该类的另外一个对象。

2.如果函数的形参是类的对象，调用函数时，进行形参和实参结合时。（相当于**传值引用会调用拷贝构造函数**，所以传递比较大的对象时，传递引用效率更高）

3.如果函数的返回值是类对象，返回函数时，调用拷贝构造函数。--用于创建无名临时对象。127页

**析构函数**

```c++
~Class(){};  //不接受任何参数，但可以是虚函数。
```

**组合类对象调用构造函数的顺序**：先调用内嵌对象的构造函数，调用顺序按照内嵌对象在组合类的定义中出现的次序，再调用本类的构造函数。析构函数相反。

**4.4.2 前向引用声明**

当两个类存在相互调用的情况，例如A类的成员函数的形参是B的对象，因为两个类的定义有次序，所以放谁在前都会出现未定义错误。在类A定义前使用Class B;作为前向引用声明。是将该类的名字告诉编译器，使编译器知道那是一个类名。

虽然使用了前向引用声明，但是在提供完整的类定义之前，仍然不能定义该类的对象或在内联函数中使用该类的对象，但是可以声明该类的对象引用或者指针。

**4.6 结构体和联合体union.**

4.6.1 结构体

结构体和类的唯一区别是：结构体默认控制属性是共有类型（public），类的默认访问控制属性为私有。

```C++
struct 结构体名称
{
   公有成员
 protected:
   保护型成员
 private:
   私有成员
};
```

引入结构体是为了保持和C程序的兼容性。

```C++
类型名 变量名 = {成员数据1初值，成员数据2初值，...}
Student stu = {97001, "Cute", ...};
stu.name;
```

4.6.2联合体

```C++
union 联合体名称
{
   公有成员
 protected:
   保护型成员
 private:
   私有成员
};
```

由于联合体的全部数据成员共享同一组内存单元，所以联合体变量中的成员同时之多只有一个是有意义的。

例如，成绩可能有等级制，是否通过或者百分制成绩。

联合体的各个对象成员，不能有自定义的构造函数，自定义析构函数和重载的复制赋值运算符；联合体不能继承，因而也不能包含多态。

### 第五章 数据的共享与保护

标识符的**可见性**讨论的是是否可以被引用。

如果对象的生存期和程序运行期相同，则称他具有**静态生存期**。

如果要在函数内部的局部作用域中声明具有静态生存期的对象，要使用**关键字static**。函数内部定义的静态局部变量不会在每次进入函数的时候创建副本，只会被初始化一次。

**全局变量和静态变量的区别：**

全局变量，静态局部变量和静态全局变量都是在**静态存储区（全局数据区）**中分配空间的，而局部变量是在**栈**上分配空间的。

全局变量作用域是整个项目，其他不包括全局变量定义的文件只需要使用extern关键字声明就可以继续使用，而静态全局变量是当前文件，静态局部变量是当前函数体内部。

**静态成员**是解决同一个类的不同对象之间数据和函数共享问题的。

**静态数据成员：**

静态成员在每个类中只有一个副本，由该类的所有对象共同维护使用，从而实现了同一个类的不同对象之间的数据共享。

静态数据成员具有静态生存期，可以通过 "类名::标识符"进行访问。

类的静态数据成员需要在类定义之外再加以定义，是因为它需要专门为他们分配空间。而非静态数据成员的空间是与他们所属对象的空间同时分配的。

```C++
private:
	static int count;
int Point::count = 0;
```

注意，虽然静态数据成员是私有的，但是也可以在类外直接初始化。

**静态函数成员：**

静态成员函数就是使用static关键字声明的函数成员，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享。

静态成员函数可以直接访问该类的静态数据成员和函数成员，而访问非静态成员，必须通过对象名。

静态成员函数**一般习惯于通过类名（或者对象名）来调用**，而非静态成员函数只能通过对象名来调用。

```C++
static void showCount(){}
Point::showCount();
```

**友元函数 friend**

通过友元关系，一个普通函数或者类的成员函数可以访问封装于另外一个类中的数据。

虽然友元函数不是本类的成员函数，但是在友元函数的函数体中可以通过对象名直接来访问类的私有数据成员。

```C++
friend float dist(Point& p1, Point& p2);  //在类内声明友元函数
float dist(Point& p1, Point& p2){}  //在类外定义友元函数，可以通过对象名直接访问类中的私有成员。
```

**友元类**

```C++
friend class A;  // 在类B中声明A为B的友元类
```

友元关系不能传递；有友元关系是单向的；友元关系不能被继承。

**5.5 共享数据的保护** 

**常对象** 

```C++
const 类型说明符 对象名；
```

必须进行初始化，而且不能被更新。

用const关键字修饰的类成员函数为**常成员函数**：

```C++
类型说明符 函数名（参数表）const；
```

常对象只能调用它的常成员函数，而不能调用其他成员函数。

const关键字可以用于重载函数的区分。

对于无须改变对象装填的成员函数，都应该使用const.

**常数据成员**

静态常数据成员在类外说明和初始化。

任何函数都不能对常数据成员进行赋值，构造函数对该数据成员进行初始化**只能通过初始化列表**。

类成员中的静态变量和常量都应当在类定义之外进行定义。例外是，类的静态常量如果是整型或者枚举型，则可以直接在类定义中为它指定常量值。

**常引用**所引用的对象不能被更新。

```C++
const 类型说明符 & 引用名；
```

无须修改传入对象的值，使用传递常引用更合适。因此，拷贝构造函数的参数一般也宜采用常引用传递。

c++语法要求一个类的定义必须出现在所有使用该类的编译单元中，习惯上，将类的定义写在头文件中。

如果一个变量除了定义它的源文件中使用之外，还能被其他文件使用，那么就称这个变量为**外部变量**。使用extern关键字定义。

在设计程序时要避免多次重复包含同一个头文件，否则会引起变量及类的重复定义。

```C++
# ifndef MYHEAD_H
# define MYHEAD_H
...
# endif
```

### 第六章 数组、指针和字符串

**数组**的声明：

```C++
数据类型 标识符[常量表达式1][常量表达式2]...;
```

数组作为函数参数：使用数组名传递数据时，传递的是地址。

把数组作为参数时，一般不指定数组第一维的大小，即使指定，也会被忽略。

**对象数组**的元素是对象。

```C++
类名 数组名[常量表达式];
数组名[下标表达式].成员名
```

**指针变量**用于存放内存单元地址。

```C++
int* ptr = &i; // int* ptr; ptr = &i;
```

数组名就是一个指针常量。

**指向常量的指针**

```C++
const int * p = &a；
```

和**指针类型的常量**

```C++
int * const p = &a；
```

void指针一般是在指针所指向的数据类型不确定时使用的。

**指针数组** 

```C++
数据类型 * 数组名[下标表达式]；
```

数组的元素都是同一类型的指针变量。

**用指针作为函数参数** （实参传地址）

当一个函数的返回值是指针类型时，这个函数就是**指针型函数**。

```C++
数据类型 * 函数名（参数表）{函数体}
```

**指向函数的指针：**

```C++
数据类型 (*函数指针名) (形参表)
  void (* functionPointer) (float);
```

**6.2.11 对象指针** 

```C++
类名 * 对象指针名；
Point* ptr = &p1;
```

适用对象指针访问对象的成员：

**对象指针名->成员名**；

**this指针**是一个隐含于每一个类的**非静态成员函数**中的特殊指针（包括构造函数和析构函数），用于指向正在被成员函数操作的对象。

this指针实际上是类成员函数的一个隐含参数，在调用类的成员函数时目的对象的地址会自动作为该参数的值，传递给被调用的成员函数，这样被调函数就能够通过this之后怎来访问目的对象的数据成员。

**动态内存分配**

在程序运行过程中申请和释放的存储单元也称为**堆对象**

```C++
new 数据类型 （初始化参数列表）;
int* point = new int;  // 如果=new int()表示用0初始化该对象
```

如果内存申请成功，**new**返回一个指向新分配内存首地址的类型的指针。

```C++
delete 指针名；
```

**new动态创建一位数组：**

```C++
new 类型名[数组长度]； //动态创建一位数组
delete[] 指针名；
```

**动态数组**

```C++
 vector<元素类型> 数组对象名(数组长度)；  //默认所有元素以0初始化
 vector<元素类型> 数组对象名(数组长度，元素初值)；
```

vector数组对象的名字表示的就是一个数组对象，而非数组的首地址。

**c++深拷贝和浅拷贝区别**

如果一个类没有提供拷贝构造函数，当用该类的一个对象去给另外一个对象赋值的时候就是浅拷贝。导致两个指针指向同一块内存，析构的时候出现指针悬挂问题出错。深拷贝会在堆内存中另外申请空间来存储数据，从而解决了指针悬挂的问题，当数据成员中有指针的时候，必须使用深拷贝。

**字符串**

### 第七章 继承与派生

**7.1类的继承和派生**

类的继承，是新的类从已有类那里得到已有的特性；

类的派生是指从已有类产生新类的过程。

```C++
class 派生类名：继承方式 基类名1，继承方式 基类名2，继承方式 //默认为私有继承
{派生成员声明；}
```

在派生过程中，构造函数和析构函数不能被继承。

派生类同名隐藏。

### 第八章 多态

**运算符重载**

**虚函数**

```C++
virtual 函数类型 函数名（形参表）;
```

虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候。

派生类的虚函数会覆盖overide基类的虚函数。

**虚析构函数**

```C++
virtual ～类名();
```

如果一个类的析构函数是虚函数，那么它派生而来的所有子类的析构函数也都是虚函数。

通过基类指针删除派生类对象时调用的是基类的析构函数，派生类的析构函数没有被执行。避免这种错误导致内存泄漏的方法是将析构函数声明为虚函数。

**抽象类**是带有**纯虚函数**的类，自身无法被实例化，只能通过继承机制，生成非抽象派生类，然后再实例化。

**纯虚函数**是一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容，要求各派生类根据具体需要给出各自的定义。

```C++
virtual 函数类型 函数名（参数表）=0；
```

------

### 侯捷老师手把手教学笔记

```C++
# include "complex.h"
```

Header(头文件)中的**防卫式声明**

```C++
# ifndef __COMPLEX__
# define __COMPLEX__
...
# endif
```

class **template**(模板)

```C++
template<typename T>
```

**inline内联函数**

函数若在class body内定义完成，便自动成为inline候选。

**构造函数**

initialization list

```C++
complex (double r=0, double i =0):re(r), im(i){};
```

名称与类名相同，没有返回值。

不带指针的类多半不用写虚构函数。

构造函数还可以有多个---overloading(重载)

构造函数放在private区？

静态函数没有this pointer；只能处理静态数据；

静态数据，需在类外定义，

```C++
double Account::m_rate=8.0;
```

Singleton设计模式：

```C++
class A{
  public:
  	static A& getInstance();
  	setup(){...}
  private:
  	A();
  	A(const A& rhs);
}

A& A::getInstance()
{
  static A a;
  return a;
}  // A::getInstance().setup();
```

**const member functions(常量成员函数)**

在函数后加const

```C++
double real() const {return re;}   //不会改变数据内容
const complex c1(1,2);  // c1.real();
```

参数传递：pass by  value vs. pass by reference(to const)

```C++
(const complex&)  //不希望被改变
```

返回值传递 return by value vs. return by reference(to const)

**friend(友元)**

**相同class的各个Objects互为friends.**

函数内局部变量不能返回reference，其他情况都可以返回引用。

**操作符重载（operator overloading）**

所有的成员函数都带有一个隐藏的参数this。

operator overloading(操作符重载，非成员函数)（无this情况）

temp object(临时对象) typename();

```C++
return complex(real(x)+real(y), imag(x)+image(y));
```

以string类为例，如果class with pointer，必须有拷贝构造和拷贝赋值函数。

```C++
String(const char* cstr = 0);
String(const String& str);  //拷贝构造函数
String& operator = (const String& str);  //拷贝赋值
~String(); // Big Three.
```

拷贝构造函数

```C++
inline String::String(const String& str)
{
  m_data = new char[strlen(str.m_data) + 1];
  strcpy(m_data, str.m_data);
}
```

拷贝赋值函数

```C++
inline String& String::operator=(const String& str)
{
  if (this == &str)  //检测自我赋值
    return *this;
  delete[] m_data;
  m_data = new char[strlen(str.m_data) + 1];
  strcpy(m_data, str.m_data);
  return *this;
}
```

**stack(栈)和heap(堆)**

栈：是存在于某个作用域的一块内存空间。例如当你调用函数，函数本身即会形成一个stack用来放置它所接受的参数，局部变量，以及返回地址。

Heap 可以通过new动态分配。

------

https://github.com/huihut/interview

1、常对象成员，只能在初始化列表赋值；

**const**可以用于重载函数的区分；

常成员函数，int getValue() const;不得修改类中的任何数据成员的值。

常对象 const A a; 常对象，只能调用常成员函数，更新常成员变量。

```C++
// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常指针
void function4(const int& Var);          // 引用参数在函数内为常量
```

**static:**

修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。

修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

**this指针：**

`this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。

当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 `this` 指针。

虚函数可以内联吗？

虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。

`inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

- 普通函数（非类成员函数）不能是虚函数
- 静态函数（static）不能是虚函数
- 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
- 内联函数不能是表现多态性时的虚函数，

**虚析构函数**是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。

```C++
class Shape
{
public:
    Shape();                    // 构造函数不能是虚函数
    virtual double calcArea();
    virtual ~Shape();           // 虚析构函数
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    shape1->calcArea();    
    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
    shape1 = NULL;
    return 0；
}
```

### 问题1：成员变量的初始化顺序？

1、成员变量在**使用初始化列表初始化时**，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。

2、如果**不使用初始化列表初始化**，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。

3、注意：类成员在定义时，是不能初始化的。

4、注意：类中const成员常量必须在构造函数初始化列表中初始化。

5、注意：类中static成员变量，必须在类外初始化。

**变量的初始化顺序**就应该是：

- 1 基类的静态变量或全局变量
- 2 派生类的静态变量或全局变量
- 3 基类的成员变量
- 4 派生类的成员变量

https://blog.csdn.net/zhaojinjia/article/details/8785912

### 问题2：C++与类型转换相关的4个关键字

const_cast, static_cast, dynamic_cast, reinterpret_cast.

```C++
static_cast<char>(i)  // 若两个类型之间相关；主要用于c++中内置的基本数据类型之间的转换
reinterpret_cast<type-id>(expression)  // type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个内置类型，也可以把一个内置类型转换成一个指针。
dynamic_cast<type-id>()  // 使用dynamic_cast进行转换的,基类中一定要有虚函数,否则编译不通过。可以将一个基类对象指针（或引用）cast到继承类指针。
const_cast<>()  // 使用const_cast可以将不是const类型的数据转换为const类型或者把const属性去掉。
```

### 问题3：智能指针



http://www.cnblogs.com/wxquare/p/4759020.html

https://blog.csdn.net/worldwindjp/article/details/18843087#comments